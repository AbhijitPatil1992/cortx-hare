#!/usr/bin/env python3

# TODO:
#
# - Validate input file.  One simple way to do this is to use
#   `yaml-to-dhall ./ClusterDesc/ClusterDesc`, but this requires
#   `yaml-to-dhall` executable that includes
#   https://github.com/dhall-lang/dhall-haskell/pull/1083 bugfix.

import abc
import argparse
import ast
from enum import Enum
import json
import random
import re
import subprocess
import sys
from typing import Any, Dict, NamedTuple, Optional, List, Union
import yaml


__version__ = '0.1'
__author__ = 'Valery V. Vorotyntsev <valery.vorotyntsev@seagate.com>'


def parse_opts(argv):
    p = argparse.ArgumentParser(
        # formatter_class=argparse.RawTextHelpFormatter,
        usage='%(prog)s [-o <output-dir>] [--mock]',
        epilog='The program reads cluster description in YAML format from the'
        " standard input; '--help-schema' option shows the schema.")
    p.add_argument('--help-schema', nargs=0, help='show cluster description'
                   ' file schema', action=ShowSchema)
    default_output_dir = 'collected-facts'
    p.add_argument('-o', metavar='output-dir',
                   help='directory to store generated files in'
                   f" (defaults to '{default_output_dir}')",
                   dest='output_dir', default=default_output_dir)
    p.add_argument('--mock', help='Generate pseudo-random "facts". The hosts'
                   ' specified in the cluster description file will not be'
                   " visited and don't even have to exist.",
                   action='store_true')
    p.add_argument('-V', '--version', action='version',
                   version='%(prog)s ' + __version__)
    return p.parse_args(argv)


class ShowSchema(argparse.Action):
    def __call__(self, *args):
        print("""\
# Cluster Description is a YAML file with the following schema:
---  # start of the document (optional)
hosts:
  - name: <str>  # [user@]hostname; e.g., localhost, samir@10.22.33.44
    disks: { path_glob: <str> }  # e.g. "/dev/loop[0-9]*"
    m0_servers:
      - endpoint:
          proto: <str>  # supported values: lo, tcp, o2ib;
                        # also supported: { tcp: <digit> }, { o2ib: <digit> }
          portal: <int>
          tmid: <int>
        runs_confd: <bool>   # optional, defaults to false
        io_disks:  # optional section; if present, IO service will be executed
          path_regex: <str>  # e.g. "."
    c0_clients:      # list of endpoints
      - { proto: <str>, portal: <int>, tmid: <int> }
    m0t1fs_clients:  # list of endpoints
      - { proto: <str>, portal: <int>, tmid: <int> }
pools:
  - name: <str>
    allowed_failures:  # optional section; no failures will be allowed
                       # if this section is missing or all of its elements
                       # are zeroes
      site: <int>
      rack: <int>
      encl: <int>
      ctrl: <int>
      disk: <int>
    data_units: <int>
    parity_units: <int>
    #
    # There are two ways of assigning disks to pool.
    #
    # 1) Choose which disks of which host to use for this pool.
    disks:
      select:
        - { host: <str>, path_regex: <str> }
    # 2) Use all available disks of all hosts for this pool.
    #disks: all
...  # end of the document (optional)""")
        sys.exit()


def main(argv=None):
    opts = parse_opts(argv)
    try:
        cluster_desc = yaml.safe_load(sys.stdin)
    except KeyboardInterrupt:
        sys.exit(1)

    for host in cluster_desc['hosts']:
        # The fact names used here correspond to version 2.4.1 of `facter`.
        # See https://puppet.com/docs/puppet/6.6/core_facts.html#legacy-facts
        host['facts'] = get_facts(host['name'], opts.mock,
                                  'hostname', 'processorcount',
                                  'memorysize_mb', 'ipaddress', 'macaddress')
        host['disks']['items'] = get_disks(host['name'],
                                           host['disks']['path_glob'])
    m0conf = build_m0conf(cluster_desc)
    # XXX DELETEME <<<<<<<
    from pprint import pprint
    print('----- cluster_desc -----')
    pprint(cluster_desc)
    print('----- m0conf -----')
    pprint(m0conf)
    print('----- dhall -----')
    for k, v in m0conf.items():
        try:
            print(v.to_dhall(k))
        except NotImplementedError:
            print('XXX-IMPLEMENTME ' + oid_to_dhall(k))
    # XXX >>>>>>>


def run_command(hostname: str, *args: str) -> str:
    assert hostname

    cmd = []  # type: List[str]
    if hostname not in ('localhost', '127.0.0.1'):
        cmd = ['ssh', hostname]
    cmd.extend(args)
    return subprocess.check_output(cmd, timeout=15).decode()


Disk = NamedTuple('Disk', [('path', str), ('size', int)])
Disk.size.__doc__ = 'Total space in bytes'


# XXX see build_disk_info() in mero's `utils/m0genfacts`
def get_disks(hostname: str, path_glob: str) -> List[Disk]:
    cmd = ['sudo', 'python3', '-c', f"""\
import glob
import io

def blockdev_size(path):
    with open(path, 'rb') as f:
        return f.seek(0, io.SEEK_END)

print([dict(path=path, size=blockdev_size(path))
       for path in glob.glob({path_glob!r})])
"""]
    return [Disk(**kwargs) for kwargs in
            ast.literal_eval(run_command(hostname, *cmd))]


def get_facts(hostname: str, mock_p: bool, *args: str) -> Dict[str, Any]:
    if mock_p:
        return fabricate_facts(hostname, *args)

    cmd = ['facter', '--json']
    cmd.extend(args)
    return json.loads(run_command(hostname, *cmd))


def fabricate_facts(hostname: str, *args: str) -> Dict[str, Any]:
    rng = random.randrange
    fabricated = {
        'hostname': re.sub('[^@]*@', '', hostname),
        'processorcount': rng(1, 21),
        'memorysize_mb': '{:.2f}'.format(random.uniform(512, 16000)),
        'ipaddress': '.'.join(str(n) for n in [
            random.choice([10, 172, 192]), rng(256), rng(256), rng(256)]),
        'macaddress': ':'.join('{:02x}'.format(n) for n in [
            rng(256), rng(256), rng(256), rng(256), rng(256), rng(256)]),
    }
    return dict((k, fabricated[k]) for k in args)


ObjT = Enum('ObjT', 'root fdmi_flt_grp fdmi_filter'
            ' node process service sdev'  # software subtree
            ' site rack enclosure controller drive'  # hardware subtree
            ' pool pver pver_f objv'  # pool subtree
            ' profile')
ObjT.__doc__ = 'Mero conf object type'


def objT_to_dhall(t: ObjT) -> str:
    return 'ObjT.' + ''.join(s.capitalize() for s in t.name.split('_'))


Oid = NamedTuple('Oid', [('type', ObjT), ('fidk', int)])
Oid.__doc__ = 'Mero conf object identifier'
Oid.fidk.__doc__ = '.f_key part of the corresponding m0_fid'


def _infinite_counter():
    k = 0
    while True:
        yield k
        k += 1


_fidk = _infinite_counter()  # fid key generator


def new_oid(objt: ObjT) -> Oid:
    return Oid(objt, next(_fidk))


def oid_to_dhall(oid: Oid) -> str:
    return f'zoid {objT_to_dhall(oid.type)} {oid.fidk}'


def oids_to_dhall(oids: List[Oid]) -> str:
    if not oids:
        return '[] : List Oid'
    return '[ {} ]'.format(', '.join(oid_to_dhall(x) for x in oids))


NetProtocol = Union[str, Dict[str, Optional[int]]]


EndpointFmt = NamedTuple('EndpointFmt', [('proto', NetProtocol),
                                         ('portal', int),
                                         ('tmid', int)])


def endpoint_to_dhall(fmt: EndpointFmt, ipaddr: str) -> str:
    if type(fmt.proto) is str:
        assert fmt.proto == 'lo'
        nid = 'NetId.lo'
    else:
        assert len(fmt.proto) == 1
        k, v = list(fmt.proto.items())[0]  # type: ignore
        assert k in ('tcp', 'ib')
        md = 'None Natural' if v is None else f'Some {v}'
        nid = f'NetId.{k} {{ {k} = {{ ipaddr = "{ipaddr}", mdigit = {md} }} }}'
    return f'{{ nid = {nid}, portal = {fmt.portal}, tmid = {fmt.tmid} }}'


class ToDhall(metaclass=abc.ABCMeta):
    @abc.abstractmethod
    def to_dhall(self, oid: Oid) -> str:
        pass


class ConfRoot(ToDhall):
    def __init__(self, nodes: List[Oid] = [], sites: List[Oid] = []):
        assert all(x.type is ObjT.node for x in nodes)
        self.nodes = nodes
        assert all(x.type is ObjT.site for x in sites)
        self.sites = sites

    def __repr__(self):
        return f'{self.__class__.__name__}(nodes={self.nodes},' \
            f' sites={self.sites})'

    def to_dhall(self, oid: Oid) -> str:
        assert oid.type is ObjT.root
        args = ', '.join([f'id = {oid_to_dhall(oid)}',
                          'mdpool = XXX',
                          'imeta_pver = XXX',
                          f'nodes = {oids_to_dhall(self.nodes)}',
                          f'sites = {oids_to_dhall(self.sites)}',
                          'pools = [XXX]',
                          'profiles = [XXX]'])
        return '{ %s }' % args


class ConfNode(ToDhall):
    def __init__(self, nr_cpu: int, memsize_MB: int,
                 processes: List[Oid] = []):
        self.nr_cpu = nr_cpu
        self.memsize_MB = memsize_MB
        assert all(x.type is ObjT.process for x in processes)
        self.processes = processes

    def __repr__(self):
        args = ', '.join([f'nr_cpu={self.nr_cpu}',
                          f'memsize_MB={self.memsize_MB}',
                          f'processes={self.processes}'])
        return f'{self.__class__.__name__}({args})'

    def to_dhall(self, oid: Oid) -> str:
        assert oid.type is ObjT.node
        args = ', '.join([f'id = {oid_to_dhall(oid)}',
                          f'nr_cpu = {self.nr_cpu}',
                          f'memsize_MB = {self.memsize_MB}',
                          f'processes = {oids_to_dhall(self.processes)}'])
        return '{ %s }' % args


class ConfProcess(ToDhall):
    def __init__(self, nr_cpu: int, memsize_MB: int, endpoint_fmt: EndpointFmt,
                 ipaddr: str, services: List[Oid] = []):
        self.nr_cpu = nr_cpu
        self.memsize_MB = memsize_MB
        self.endpoint_fmt = endpoint_fmt
        self.ipaddr = ipaddr
        assert all(x.type is ObjT.service for x in services)
        self.services = services

    def __repr__(self):
        args = ', '.join([f'nr_cpu={self.nr_cpu}',
                          f'memsize_MB={self.memsize_MB}',
                          f'endpoint_fmt={self.endpoint_fmt}',
                          f'ipaddr={self.ipaddr!r}',
                          f'services={self.services}'])
        return f'{self.__class__.__name__}({args})'

    def to_dhall(self, oid: Oid) -> str:
        assert oid.type is ObjT.process
        endpoint = endpoint_to_dhall(self.endpoint_fmt, self.ipaddr)
        args = ', '.join([f'id = {oid_to_dhall(oid)}',
                          f'nr_cpu = {self.nr_cpu}',
                          f'memsize_MB = {self.memsize_MB}',
                          f'endpoint = {endpoint}',
                          f'services = {oids_to_dhall(self.services)}'])
        return '{ %s }' % args


class ConfSite(ToDhall):
    def __init__(self, racks: List[Oid] = []):
        assert all(x.type is ObjT.rack for x in racks)
        self.racks = racks

    def __repr__(self):
        return f'{self.__class__.__name__}(racks={self.racks})'

    def to_dhall(self, oid: Oid) -> str:
        assert oid.type is ObjT.site
        args = ', '.join([f'id = {oid_to_dhall(oid)}',
                          f'racks = {oids_to_dhall(self.racks)}',
                          'pvers = [XXX]'])
        return '{ %s }' % args


class ConfRack(ToDhall):
    def __init__(self, encls: List[Oid] = []):
        assert all(x.type is ObjT.enclosure for x in encls)
        self.encls = encls

    def __repr__(self):
        return f'{self.__class__.__name__}(encls={self.encls})'

    def to_dhall(self, oid: Oid) -> str:
        assert oid.type is ObjT.rack
        args = ', '.join([f'id = {oid_to_dhall(oid)}',
                          f'encls = {oids_to_dhall(self.encls)}',
                          f'pvers = [XXX]'])
        return '{ %s }' % args


class ConfEnclosure(ToDhall):
    def __init__(self, ctrls: List[Oid] = []):
        assert all(x.type is ObjT.controller for x in ctrls)
        self.ctrls = ctrls

    def __repr__(self):
        return f'{self.__class__.__name__}(ctrls={self.ctrls})'

    def to_dhall(self, oid: Oid) -> str:
        assert oid.type is ObjT.enclosure
        args = ', '.join([f'id = {oid_to_dhall(oid)}',
                          f'ctrls = {oids_to_dhall(self.ctrls)}',
                          f'pvers = [XXX]'])
        return '{ %s }' % args


class ConfController(ToDhall):
    def __init__(self, node: Oid, drives: List[Oid] = []):
        assert node.type is ObjT.node
        self.node = node
        assert all(x.type is ObjT.drive for x in drives)
        self.drives = drives

    def __repr__(self):
        return f'{self.__class__.__name__}(node={self.node},' \
            f' drives={self.drives})'

    def to_dhall(self, oid: Oid) -> str:
        assert oid.type is ObjT.controller
        args = ', '.join([f'id = {oid_to_dhall(oid)}',
                          f'node = {oid_to_dhall(self.node)}',
                          f'drives = {oids_to_dhall(self.drives)}',
                          f'pvers = [XXX]'])
        return '{ %s }' % args


def build_m0conf(cluster_desc: Dict[str, Any]) -> Dict[Oid, ToDhall]:
    conf = {}  # type: Dict[Oid, Any]

    root_id = new_oid(ObjT.root)
    conf[root_id] = ConfRoot()

    site_id = new_oid(ObjT.site)
    conf[site_id] = ConfSite()
    conf[root_id].sites = [site_id]

    rack_id = new_oid(ObjT.rack)
    conf[rack_id] = ConfRack()
    conf[site_id].racks = [rack_id]

    encl_id = new_oid(ObjT.enclosure)
    conf[encl_id] = ConfEnclosure()
    conf[rack_id].encls = [encl_id]

    for host in cluster_desc['hosts']:
        nr_cpu = host['facts']['processorcount']
        memsize_MB = int(float(host['facts']['memorysize_mb']))

        node_id = new_oid(ObjT.node)
        conf[node_id] = ConfNode(nr_cpu=nr_cpu, memsize_MB=memsize_MB)
        conf[root_id].nodes.append(node_id)

        ctrl_id = new_oid(ObjT.controller)
        conf[ctrl_id] = ConfController(node_id)
        conf[encl_id].ctrls.append(ctrl_id)

        for proc in host['m0_servers']:
            # XXX How many processes should we create?
            # XXX See "mero roles" file in `halon` repository:
            # XXX mero-halon/scripts/mero_clovis_role_mappings.ede
            proc_id = new_oid(ObjT.process)
            conf[proc_id] = ConfProcess(
                nr_cpu=nr_cpu, memsize_MB=memsize_MB,
                endpoint_fmt=EndpointFmt(**proc['endpoint_fmt']),
                ipaddr=host['facts']['ipaddress'])
            conf[node_id].processes.append(proc_id)
        # XXX c0_clients, m0t1fs_clients

    return conf


if __name__ == '__main__':
    main()
