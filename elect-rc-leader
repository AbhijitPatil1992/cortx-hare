#!/usr/bin/env bash
set -eu -o pipefail

#
# This is the handler for RC Leader election.
#
# It creates the session with confd health checker and
# tries to acquire the leader lock with this session.
#
# Use it like this:
#
# $ consul watch -type=key -key leader elect-rc-leader
#

# Redirect all printouts to the log file with the timestamp prefix:
exec &>> /tmp/consul-$(basename $0).log
exec &> >(stdbuf -oL gawk '{ print strftime("%Y-%m-%d %H:%M:%S"), $0 }')

export SRC_DIR="$(dirname $(readlink -f $0))"

get_session_id() {
    consul kv get -detailed leader | awk '/Session/ {print $2}'
}

# If the session is already set - the leader is elected, so
# there is nothing for us to do.
get_session_id | grep -q ^- || exit 0

# Stop the EQ watch (if any):
pkill -9 -f 'consul watch.*prefix eq' || true
# Nicely stop currently running RC handler (if any):
pkill -f 'sh.*proto-rc' || true

# Create session with the service:confd Health Checker:
CHECKS=$(curl -s http://127.0.0.1:8500/v1/health/node/`hostname` | jq '[.[].CheckID]')
PAYLD="{\"Name\": \"leader\", \"Checks\": $CHECKS}"
RES=$(curl -sX PUT -d "$PAYLD" http://localhost:8500/v1/session/create)
SID=$(echo "$RES" | jq -r '.ID' 2>/dev/null || true)

[[ $SID ]] || {
    echo "Session creation failed: $RES" >&2
    exit 0  # don't stop our watch
}

clean_exit() {
    curl -sX PUT http://localhost:8500/v1/session/destroy/$SID &>/dev/null ||
        true
    exit 0
}

# Try to acquire the lock unless it's already acquired by someone else:
while true; do
    get_session_id | grep -q ^- || clean_exit
    sleep $((RANDOM % 10))
    consul kv put -acquire -session=$SID leader `hostname` 2>/dev/null && break
done

# We've got the lock! Start the leader in background:
export SID
(
    # Destroy the session when leader dies:
    trap "curl -sX PUT http://localhost:8500/v1/session/destroy/$SID &>/dev/null" EXIT

    # XXX: notify Mero about new Principal RM here

    # Start EQ watch:
    consul watch -type=keyprefix -prefix eq/ $SRC_DIR/proto-rc
) &
