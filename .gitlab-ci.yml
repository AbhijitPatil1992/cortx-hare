# Globals ----------------------------------------------------------------- {{{1
#

variables:
  GIT_DEPTH: 1  # clone only the current commit
  GIT_STRATEGY: clone  # make a fresh `git clone` of the repo for every new CI job
  GIT_SUBMODULE_STRATEGY: normal  # init and check out submodules
  CENTOS_RELEASE: '7.6'
  DOCKER_REGISTRY: registry.gitlab.mero.colo.seagate.com
  M0_VG_NO_SYMLINKS: "true"
  RPMSYNC_DIR:    "/releases/dev/$CI_PROJECT_PATH/$CI_COMMIT_REF_SLUG/B$CI_PIPELINE_ID"
  WORKSPACE_NAME: "${CI_PROJECT_NAME}${CI_PIPELINE_ID}"
  WORKSPACE_DIR:  "/home/gitlab-runner/workspaces/${CI_PROJECT_NAME}${CI_PIPELINE_ID}"

stages:
  - build
  - test
  - cleanup

before_script:
  - date -u -Isec
  - git log -1 --pretty=fuller
  - printenv

after_script:
  - date -u -Isec

# Build ------------------------------------------------------------------- {{{1
#

build:
  stage: build
  tags: [ m0vg ]
  except: [ tags ]
  script: [ ci/build ]

rpmbuild:
  stage: build
  tags: [ docker-build ]
  except: [ tags ]
  image: $DOCKER_REGISTRY/mero/hare:$CENTOS_RELEASE
  script: [ ci/rpmbuild ]

# Test ----------------------------------------------------------------- {{{1
#

test-utils:
  stage: test
  tags: [ m0vg ]
  except: [ tags ]
  script: [ ci/test-utils ]

# See https://docs.gitlab.com/ce/ci/yaml/README.html#anchors
.after_script_template: &after_script_definition
  - date -u -Isec
  - cd $WORKSPACE_DIR
  - /usr/bin/time hare/ci/collect-artifacts

  # Clean up.  This ensures that VMs are destroyed in case of a manual
  # job restart, when global 'cleanup' stage is not performed.
  - $M0VG destroy -f || true

.artifacts_template: &artifacts_definition
  name: "$CI_PROJECT_NAME job $CI_JOB_ID ($CI_JOB_NAME) logs"
  when: always  # whenever the job has failed or succeeded
  paths:
    - ${CI_JOB_NAME}*consul*.log
    - ${CI_JOB_NAME}*m0reportbug-data.tar.xz
    # - ${CI_JOB_NAME}*m0reportbug-cores.tar.xz  # XXX too big
    - ${CI_JOB_NAME}*m0reportbug-traces.tar.xz
    - ${CI_JOB_NAME}*syslog.log

test-boot1:
  stage: test
  tags: [ m0vg ]
  except: [ tags ]
  variables: { M0VG: m0vg-1node/scripts/m0vg }
  script: [ ci/test-boot1 ]
  after_script: *after_script_definition
  artifacts: *artifacts_definition

test-boot2:
  stage: test
  tags: [ m0vg ]
  except: [ tags ]
  variables: { M0VG: m0vg-2nodes/scripts/m0vg }
  script: [ ci/test-boot2 ]
  after_script: *after_script_definition
  artifacts: *artifacts_definition

# Cleanup ----------------------------------------------------------------- {{{1
#

cleanup:
  stage: cleanup
  tags: [ m0vg ]
  except: [ tags ]
  when: always
  dependencies: []  # empty deps list prevents unneeded artifacts downloading

  variables:
    # If a branch is updated while CI tests for the older commit are still
    # being run, the checkout phase of 'cleanup' job will fail (thus cleanup
    # script will not run) unless GIT_DEPTH is deep enough to include the older
    # commit. Cloning 30 latest commits seems to be good enough - it's quite
    # rare for people to push more than 30 new commits in one go.
    GIT_DEPTH: 30

  script:
    - cd $WORKSPACE_DIR
    - m0vg-1node/scripts/m0vg destroy -f || true
    - m0vg-2nodes/scripts/m0vg destroy -f || true

# Docker images ----------------------------------------------------------- {{{1
#

docker:rebuild-images:
  stage: build
  tags: [ docker-image-build ]
  when: manual
  only:
    changes:
      - docker/**/*
  except: [ schedules ]

  variables:
    DOCKER_IMAGE_TAG: latest

  script:
    - cd docker/
    - make docker-image-${DOCKER_IMAGE_TAG}
    - make push tag="${DOCKER_IMAGE_TAG}*"


docker:rebuild-images:76:
  extends: docker:rebuild-images
  variables:
    DOCKER_IMAGE_TAG: '7.6'


docker:rebuild-images:eos:
  extends: docker:rebuild-images
  variables:
    DOCKER_IMAGE_TAG: eos


# vim: foldmethod=marker shiftwidth=2 tabstop=2 expandtab
