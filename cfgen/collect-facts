#!/usr/bin/env python3

# TODO:
#
# - Validate input file.  One simple way to do this is to use
#   `yaml-to-dhall ./ClusterDesc/ClusterDesc`, but this requires
#   `yaml-to-dhall` executable that includes
#   https://github.com/dhall-lang/dhall-haskell/pull/1083 bugfix.

import argparse
import ast
from collections import namedtuple
import json
import random
import re
import subprocess
import sys
from typing import Any, Dict, List
import yaml


__version__ = '0.1'
__author__ = 'Valery V. Vorotyntsev <valery.vorotyntsev@seagate.com>'


def parse_opts(argv):
    p = argparse.ArgumentParser(
        # formatter_class=argparse.RawTextHelpFormatter,
        usage='%(prog)s [-o <output-dir>] [--mock]',
        epilog='The program reads cluster description in YAML format from the'
        " standard input; '--help-schema' option shows the schema.")
    p.add_argument('--help-schema', nargs=0, help='show cluster description'
                   ' file schema', action=ShowSchema)
    default_output_dir = 'collected-facts'
    p.add_argument('-o', metavar='output-dir',
                   help='directory to store generated files in'
                   f" (defaults to '{default_output_dir}')",
                   dest='output_dir', default=default_output_dir)
    p.add_argument('--mock', help='Generate pseudo-random "facts". The hosts'
                   ' specified in the cluster description file will not be'
                   " visited and don't even have to exist.",
                   action='store_true')
    p.add_argument('-V', '--version', action='version',
                   version='%(prog)s ' + __version__)
    return p.parse_args(argv)


class ShowSchema(argparse.Action):
    def __call__(self, *args):
        print("""\
# Cluster Description is a YAML file with the following schema:
---  # start of the document (optional)
hosts:
  - name: <str>  # [user@]hostname; e.g., localhost, samir@10.22.33.44
    disks: { path_glob: <str> }  # e.g. "/dev/loop[0-9]*"
    m0_servers:
      - endpoint:
          proto: <str>  # supported values: lo, tcp, o2ib;
                        # also supported: { tcp: <digit> }, { o2ib: <digit> }
          portal: <int>
          tmid: <int>
        runs_confd: <bool>   # optional, defaults to false
        io_disks:  # optional section; if present, IO service will be executed
          path_regex: <str>  # e.g. "."
    c0_clients:      # list of endpoints
      - { proto: <str>, portal: <int>, tmid: <int> }
    m0t1fs_clients:  # list of endpoints
      - { proto: <str>, portal: <int>, tmid: <int> }
pools:
  - name: <str>
    allowed_failures:  # optional section; no failures will be allowed
                       # if this section is missing or all of its elements
                       # are zeroes
      site: <int>
      rack: <int>
      encl: <int>
      ctrl: <int>
      disk: <int>
    data_units: <int>
    parity_units: <int>
    #
    # There are two ways of assigning disks to pool.
    #
    # 1) Choose which disks of which host to use for this pool.
    disks:
      select:
        - { host: <str>, path_regex: <str> }
    # 2) Use all available disks of all hosts for this pool.
    #disks: all
...  # end of the document (optional)""")
        sys.exit()


def main(argv=None):
    opts = parse_opts(argv)
    try:
        cluster_desc = yaml.safe_load(sys.stdin)
    except KeyboardInterrupt:
        sys.exit(1)

    for host in cluster_desc['hosts']:
        # The fact names used here correspond to version 2.4.1 of `facter`.
        # See https://puppet.com/docs/puppet/6.6/core_facts.html#legacy-facts
        host['facts'] = get_facts(host['name'], opts.mock,
                                  'hostname', 'processorcount',
                                  'memorysize_mb', 'ipaddress', 'macaddress')
        host['disks']['items'] = get_disks(host['name'],
                                           host['disks']['path_glob'])
    # XXX DELETEME <<<<<<<
    from pprint import pprint
    pprint(cluster_desc)
    # XXX >>>>>>>


def run_command(hostname: str, *args: str) -> str:
    assert hostname

    cmd = []  # type: List[str]
    if hostname not in ('localhost', '127.0.0.1'):
        cmd = ['ssh', hostname]
    cmd.extend(args)
    return subprocess.check_output(cmd, timeout=15).decode()


Disk = namedtuple('Disk', 'path size')
Disk.size.__doc__ = 'Total space in bytes'


# XXX see build_disk_info() in mero's `utils/m0genfacts`
def get_disks(hostname: str, path_glob: str) -> List[Disk]:
    cmd = ['sudo', 'python3', '-c', f"""\
import glob
import io

def blockdev_size(path):
    with open(path, 'rb') as f:
        return f.seek(0, io.SEEK_END)

print([dict(path=path, size=blockdev_size(path))
       for path in glob.glob({path_glob!r})])
"""]
    return [Disk(**kwargs) for kwargs in
            ast.literal_eval(run_command(hostname, *cmd))]


def get_facts(hostname: str, mock_p: bool, *args: str) -> Dict[str, Any]:
    if mock_p:
        return fabricate_facts(hostname, *args)

    cmd = ['facter', '--json']
    cmd.extend(args)
    return json.loads(run_command(hostname, *cmd))


def fabricate_facts(hostname: str, *args: str) -> Dict[str, Any]:
    rng = random.randrange
    fabricated = {
        'hostname': re.sub('[^@]*@', '', hostname),
        'processorcount': rng(1, 21),
        'memorysize_mb': '{:.2f}'.format(random.uniform(512, 16000)),
        'ipaddress': '.'.join(str(n) for n in [
            random.choice([10, 172, 192]), rng(256), rng(256), rng(256)]),
        'macaddress': ':'.join('{:02x}'.format(n) for n in [
            rng(256), rng(256), rng(256), rng(256), rng(256), rng(256)]),
    }
    return dict((k, fabricated[k]) for k in args)


#XXX# def register_confobj_types():
#XXX#     for t in ('dir', 'root', 'profile', 'filesystem', 'pool', 'pver', 'objv',
#XXX#               'node', 'process', 'service', 'sdev', 'rack', 'enclosure',
#XXX#               'controller', 'disk'):
#XXX#         globals()['conf_' + t] = type('conf_' + t, (ConfObj,), {})
#XXX#
#XXX#
#XXX# def build_conf_graph(cluster_desc: Dict[str, Any]):
#XXX#     XXX


#XXX## XXX ----------------------------------------------------------------
#XXX#
#XXX#
#XXX## _singlenode_desc = """\
#XXX## hosts:
#XXX##   - name: localhost
#XXX##     disks: { path_glob: "/dev/loop[0-9]*" }
#XXX##     m0_servers:
#XXX##       - endpoint: { proto: lo, portal: 34, tmid: 101 }
#XXX##         runs_confd: true
#XXX##         io_disks: { path_regex: . }
#XXX##     c0_clients: []
#XXX##     m0t1fs_clients: []
#XXX## pools:
#XXX##   - name: the pool
#XXX##     allowed_failures: { ctrl: 0, disk: 0 }
#XXX##     data_units: 1
#XXX##     parity_units: 0
#XXX##     disks: all
#XXX## """
#XXX#
#XXX#
#XXX#class Endpoint:
#XXX#    nid_suffix: str
#XXX#
#XXX#    def __init__(self, **kwargs):
#XXX#        def raise_error(msg=None):
#XXX#            raise ValueError(f'Invalid endpoint: {kwargs!r}' +
#XXX#                             '' if msg is None else '\n' + msg))
#XXX#
#XXX#        if len(kwargs) != 3 or set(kwargs) != {'proto', 'portal', 'tmid'}:
#XXX#            raise_error()
#XXX#
#XXX#        proto = kwargs['proto']
#XXX#        if type(proto) is str:
#XXX#            supported = ('lo', 'tcp', 'o2ib')
#XXX#            if proto not in supported:
#XXX#                raise_error('`proto` must be one of: ' + ', '.join(supported))
#XXX#            self.nid_suffix = '@' + proto
#XXX#        elif type(proto) is dict and len(proto) == 1:
#XXX#            proto, optional_digit = list(proto.items())[0]
#XXX#            if proto not in ('tcp', 'o2ib'):
#XXX#                raise_error()
#XXX#            self.nid_suffix = '@' + proto
#XXX#            if optional_digit is not None:
#XXX#                if not (type(optional_digit) is int and \
#XXX#                        (0 < optional_digit < 9)):
#XXX#                    raise_error(f'Digit expected, e.g. `{proto}: 1`')
#XXX#                self.nid_suffix += str(optional_digit)
#XXX#        else:
#XXX#            raise_error('Invalid `proto` specification')
#XXX#
#XXX#        portal, tmid = kwargs['portal'], kwargs['tmid']
#XXX#        if not ({type(portal), type(tmid)} == {int} and \
#XXX#                portal > 0 and tmid > 0):
#XXX#            raise_error('`portal` and `tmid` must be natural numbers')
#XXX#
#XXX#        self.nid_suffix += f':12345:{portal}:{tmid}'
#XXX#
#XXX#
#XXX#class Host:
#XXX#    name: str
#XXX#    disks_path_glob: str
#XXX#    # m0_servers: List[M0_Server]
#XXX#    # c0_clients: List[Endpoint]
#XXX#    # m0t1fs_clients: List[Endpoint]
#XXX#
#XXX#    def __init__(self, **kwargs):
#XXX#        self.name = kwargs['name']
#XXX#        self.disks_path_glob = kwargs['disks']['path_glob']
#XXX#        # self.m0_servers = [M0Server(x) for x in kwargs['m0_servers']]
#XXX#        # self.c0_clients = [Endpoint(x) for x in kwargs['c0_clients']]
#XXX#        # self.m0t1fs_clients = [Endpoint(x) for x in kwargs['m0t1fs_clients']]
#XXX#
#XXX#
#XXX#class Cluster:
#XXX#    hosts: List[Host]
#XXX#    # pools: List[Pool]
#XXX#
#XXX#    def __init__(self, **kwargs):
#XXX#        self.hosts = [Host(x) for x in kwargs['hosts']]
#XXX#        # self.pools = [Pool(x) for x in kwargs['pools']]
#XXX#
#XXX#
#XXX#def collect_facts(cluster: Cluster) -> Dict[str, Any]:
#XXX#    for host in cluster.hosts:
#XXX#        # Sanitize user input, preventing malicious host names like
#XXX#        # "127.0.0.1; rm -rf ~; sudo rm -rf /;".
#XXX#        if re.match('[a-z][-@_.a-z0-9]*', host.name) is None:
#XXX#            raise ValueError('Invalid host reference: ' + host.name)
#XXX#
#XXX#        # These facts were obtained using version 2.4.1 of `facter`.
#XXX#        # See https://puppet.com/docs/puppet/6.6/core_facts.html#legacy-facts
#XXX#        mock_facts = {'hostname': 'cmu',
#XXX#                      'processorcount': 3,
#XXX#                      'memorysize_mb': '2846.40',
#XXX#                      'ipaddress': '10.0.1.23',
#XXX#                      'macaddress': '12:34:56:78:9a:bc'}
#XXX#
#XXX#        if mode != OpMode.MOCK:
#XXX#            args = ['ssh', host.name] if mode == OpMode.SSH else []
#XXX#            args.extend(['facter', '--json'])
#XXX#            args.extend(mock_facts.keys())
#XXX#            facts = json.loads(subprocess.check_output(args, timeout=15)
#XXX#                               .decode())
#XXX#
#XXX#
#XXX## def store_facts(facts: Facts, output_dir: str = None):
#XXX##     pass
#XXX## XXX ----------------------------------------------------------------


if __name__ == '__main__':
    main()
