#!/usr/bin/env python3

# TODO:
#
# - Validate input file.  One simple way to do this is to use
#   `yaml-to-dhall ./ClusterDesc/ClusterDesc`, but this requires
#   `yaml-to-dhall` executable that includes
#   https://github.com/dhall-lang/dhall-haskell/pull/1083 bugfix.

import argparse
import ast
from enum import Enum
import json
import random
import re
import subprocess
import sys
from typing import Any, Dict, NamedTuple, List
import yaml


__version__ = '0.1'
__author__ = 'Valery V. Vorotyntsev <valery.vorotyntsev@seagate.com>'


def parse_opts(argv):
    p = argparse.ArgumentParser(
        # formatter_class=argparse.RawTextHelpFormatter,
        usage='%(prog)s [-o <output-dir>] [--mock]',
        epilog='The program reads cluster description in YAML format from the'
        " standard input; '--help-schema' option shows the schema.")
    p.add_argument('--help-schema', nargs=0, help='show cluster description'
                   ' file schema', action=ShowSchema)
    default_output_dir = 'collected-facts'
    p.add_argument('-o', metavar='output-dir',
                   help='directory to store generated files in'
                   f" (defaults to '{default_output_dir}')",
                   dest='output_dir', default=default_output_dir)
    p.add_argument('--mock', help='Generate pseudo-random "facts". The hosts'
                   ' specified in the cluster description file will not be'
                   " visited and don't even have to exist.",
                   action='store_true')
    p.add_argument('-V', '--version', action='version',
                   version='%(prog)s ' + __version__)
    return p.parse_args(argv)


class ShowSchema(argparse.Action):
    def __call__(self, *args):
        print("""\
# Cluster Description is a YAML file with the following schema:
---  # start of the document (optional)
hosts:
  - name: <str>  # [user@]hostname; e.g., localhost, samir@10.22.33.44
    disks: { path_glob: <str> }  # e.g. "/dev/loop[0-9]*"
    m0_servers:
      - endpoint:
          proto: <str>  # supported values: lo, tcp, o2ib;
                        # also supported: { tcp: <digit> }, { o2ib: <digit> }
          portal: <int>
          tmid: <int>
        runs_confd: <bool>   # optional, defaults to false
        io_disks:  # optional section; if present, IO service will be executed
          path_regex: <str>  # e.g. "."
    c0_clients:      # list of endpoints
      - { proto: <str>, portal: <int>, tmid: <int> }
    m0t1fs_clients:  # list of endpoints
      - { proto: <str>, portal: <int>, tmid: <int> }
pools:
  - name: <str>
    allowed_failures:  # optional section; no failures will be allowed
                       # if this section is missing or all of its elements
                       # are zeroes
      site: <int>
      rack: <int>
      encl: <int>
      ctrl: <int>
      disk: <int>
    data_units: <int>
    parity_units: <int>
    #
    # There are two ways of assigning disks to pool.
    #
    # 1) Choose which disks of which host to use for this pool.
    disks:
      select:
        - { host: <str>, path_regex: <str> }
    # 2) Use all available disks of all hosts for this pool.
    #disks: all
...  # end of the document (optional)""")
        sys.exit()


def main(argv=None):
    opts = parse_opts(argv)
    try:
        cluster_desc = yaml.safe_load(sys.stdin)
    except KeyboardInterrupt:
        sys.exit(1)

    for host in cluster_desc['hosts']:
        # The fact names used here correspond to version 2.4.1 of `facter`.
        # See https://puppet.com/docs/puppet/6.6/core_facts.html#legacy-facts
        host['facts'] = get_facts(host['name'], opts.mock,
                                  'hostname', 'processorcount',
                                  'memorysize_mb', 'ipaddress', 'macaddress')
        host['disks']['items'] = get_disks(host['name'],
                                           host['disks']['path_glob'])
    m0conf = build_m0conf(cluster_desc)
    # XXX DELETEME <<<<<<<
    from pprint import pprint
    print('----- cluster_desc -----')
    pprint(cluster_desc)
    print('----- m0conf -----')
    pprint(m0conf)
    # XXX >>>>>>>


def run_command(hostname: str, *args: str) -> str:
    assert hostname

    cmd = []  # type: List[str]
    if hostname not in ('localhost', '127.0.0.1'):
        cmd = ['ssh', hostname]
    cmd.extend(args)
    return subprocess.check_output(cmd, timeout=15).decode()


Disk = NamedTuple('Disk', [('path', str), ('size', int)])
Disk.size.__doc__ = 'Total space in bytes'


# XXX see build_disk_info() in mero's `utils/m0genfacts`
def get_disks(hostname: str, path_glob: str) -> List[Disk]:
    cmd = ['sudo', 'python3', '-c', f"""\
import glob
import io

def blockdev_size(path):
    with open(path, 'rb') as f:
        return f.seek(0, io.SEEK_END)

print([dict(path=path, size=blockdev_size(path))
       for path in glob.glob({path_glob!r})])
"""]
    return [Disk(**kwargs) for kwargs in
            ast.literal_eval(run_command(hostname, *cmd))]


def get_facts(hostname: str, mock_p: bool, *args: str) -> Dict[str, Any]:
    if mock_p:
        return fabricate_facts(hostname, *args)

    cmd = ['facter', '--json']
    cmd.extend(args)
    return json.loads(run_command(hostname, *cmd))


def fabricate_facts(hostname: str, *args: str) -> Dict[str, Any]:
    rng = random.randrange
    fabricated = {
        'hostname': re.sub('[^@]*@', '', hostname),
        'processorcount': rng(1, 21),
        'memorysize_mb': '{:.2f}'.format(random.uniform(512, 16000)),
        'ipaddress': '.'.join(str(n) for n in [
            random.choice([10, 172, 192]), rng(256), rng(256), rng(256)]),
        'macaddress': ':'.join('{:02x}'.format(n) for n in [
            rng(256), rng(256), rng(256), rng(256), rng(256), rng(256)]),
    }
    return dict((k, fabricated[k]) for k in args)


ObjT = Enum('ObjT', 'root fdmi_flt_grp fdmi_filter'
            ' node process service sdev'  # software subtree
            ' site rack enclosure controller drive'  # hardware subtree
            ' pool pver pver_f objv'  # pool subtree
            ' profile')
ObjT.__doc__ = 'Mero conf object type'


Oid = NamedTuple('Oid', [('type', ObjT), ('fidk', int)])
Oid.__doc__ = 'Mero conf object identifier'
Oid.fidk.__doc__ = '.f_key part of the corresponding m0_fid'


def _infinite_counter():
    k = 0
    while True:
        yield k
        k += 1


_fidk = _infinite_counter()  # fid key generator


def new_oid(objt: ObjT) -> Oid:
    return Oid(objt, next(_fidk))


# XXX Convert to an abstract base class (ABC).
# See https://mypy.readthedocs.io/en/stable/class_basics.html#abstract-base-classes-and-multiple-inheritance
class ToDhall:
    def to_dhall(self):
        raise NotImplementedError('XXX IMPLEMENTME')


class ConfRoot(ToDhall):
    def __init__(self, nodes: List[Oid] = []):
        self.nodes = nodes

    def __repr__(self):
        return f'{self.__class__.__name__}(nodes={self.nodes})'


class ConfNode(ToDhall):
    def __init__(self, memsize_MB: int, nr_cpu: int,
                 processes: List[Oid] = []):
        self.memsize_MB = memsize_MB
        self.nr_cpu = nr_cpu
        self.processes = processes

    def __repr__(self):
        return f'{self.__class__.__name__}(memsize_MB={self.memsize_MB},' \
            f' nr_cpu={self.nr_cpu}, processes={self.processes})'


class ConfController(ToDhall):
    def __init__(self, node: Oid, drives: List[Oid] = []):
        assert node.type is ObjT.node
        self.node = node
        assert all(x.type is ObjT.drive for x in drives)
        self.drives = drives
        self.pvers = []  # type: List[Oid]

    def __repr__(self):
        return f'{self.__class__.__name__}(node={self.node},' \
            f' drives={self.drives})'


def build_m0conf(cluster_desc: Dict[str, Any]) -> Dict[Oid, ToDhall]:
    conf = {}  # type: Dict[Oid, Any]

    root = new_oid(ObjT.root)
    conf[root] = ConfRoot()

    for host in cluster_desc['hosts']:
        node = new_oid(ObjT.node)
        conf[root].nodes.append(node)
        conf[node] = ConfNode(
            memsize_MB=int(float(host['facts']['memorysize_mb'])),
            nr_cpu=host['facts']['processorcount'])
        conf[new_oid(ObjT.controller)] = ConfController(node)

    return conf


if __name__ == '__main__':
    main()
