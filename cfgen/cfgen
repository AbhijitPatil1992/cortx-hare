#!/usr/bin/env python3

import abc
import argparse
import ast
from enum import Enum, auto
import json
import os
import random
import re
import subprocess
import sys
from typing import Any, Callable, Dict, NamedTuple, List, Tuple
import yaml


__version__ = '0.1'
__author__ = 'Valery V. Vorotyntsev <valery.vorotyntsev@seagate.com>'


def parse_opts(argv):
    p = argparse.ArgumentParser(
        description='Generate configuration files required to start'
        ' Mero cluster.',
        usage='%(prog)s [-o <output-dir>] [--mock]',
        epilog='The program reads cluster description in YAML format from the'
        " standard input; '--help-schema' option shows the schema.")
    p.add_argument('--help-schema', nargs=0, help='show cluster description'
                   ' file schema', action=ShowSchema)
    # default_dhall_dir = '/opt/cfgen/dhall'
    # p.add_argument('--dhall', metavar='dir',
    #                help='directory with auxiliary Dhall expressions'
    #                f' (defaults to {default_dhall_dir!r})',
    #                dest='dhall_dir', default=default_dhall_dir)
    p.add_argument('-o', metavar='output-dir',
                   help="output directory (defaults to '.')",
                   dest='output_dir', default='.')
    p.add_argument('--mock', help='Generate pseudo-random "facts". The hosts'
                   ' specified in the cluster description file will not be'
                   " visited and don't even have to exist.",
                   action='store_true')
    p.add_argument('-V', '--version', action='version',
                   version='%(prog)s ' + __version__)
    opts = p.parse_args(argv)

    # Sanity checking
    d = opts.output_dir
    if not (d and os.path.isdir(d) and os.access(d, os.X_OK | os.W_OK)):
        print("`-o' argument must be a path to writable directory",
              file=sys.stderr)
        sys.exit(1)

    return opts


class ShowSchema(argparse.Action):
    def __call__(self, *args):
        print("""\
# Cluster Description is a YAML file with the following schema:
---  # start of the document (optional)
hosts:
  - name: <str>  # [user@]hostname; e.g., localhost, samir@10.22.33.44
    disks: { path_glob: <str> }  # e.g. "/dev/loop[0-9]*"
    m0_servers:
      - runs_confd: <bool>   # optional, defaults to false
        io_disks:
          path_regex: <str>  # e.g. "."; empty string means no IO service
    c0_clients: <int>        # max quantity of Clovis apps this host may have
    m0t1fs_clients: <int>    # max quantity of m0t1fs clients
pools:
  - name: <str>
    allowed_failures:  # optional section; no failures will be allowed
                       # if this section is missing or all of its elements
                       # are zeroes
      site: <int>
      rack: <int>
      encl: <int>
      ctrl: <int>
      disk: <int>
    data_units: <int>
    parity_units: <int>
    #
    # There are two ways of assigning disks to pool.
    #
    # 1) Choose which disks of which host to use for this pool.
    disks:
      select:
        - { host: <str>, path_regex: <str> }
    # 2) Use all available disks of all hosts for this pool.
    #disks: all
...  # end of the document (optional)""")
        sys.exit()


def ensure_compliant(input_str: str, path: str):
    p = subprocess.Popen(['yaml-to-dhall', path],
                         stdin=subprocess.PIPE,
                         stdout=subprocess.PIPE,
                         stderr=subprocess.PIPE)
    output, err = p.communicate(input=input_str.encode())
    rc = p.returncode
    if rc != 0:
        print('Wrong input string given')
        print(output.decode())
        print(err.decode())
        sys.exit(rc)


def main(argv=None):
    opts = parse_opts(argv)
    try:
        input_str = sys.stdin.read()
        cluster_desc = yaml.safe_load(input_str)
        dir_path = os.path.dirname(os.path.realpath(__file__))
        ensure_compliant(input_str,
                         '{}/dhall/ClusterDesc/ClusterDesc'.format(dir_path))
    except KeyboardInterrupt:
        sys.exit(1)

    for host in cluster_desc['hosts']:
        # The fact names used here correspond to version 2.4.1 of `facter`.
        # See https://puppet.com/docs/puppet/6.6/core_facts.html#legacy-facts
        host['facts'] = get_facts(host['name'], opts.mock,
                                  'hostname', 'processorcount',
                                  'memorysize_mb', 'ipaddress', 'macaddress')
        host['facts']['_memsize_MB'] = int(float(
            host['facts']['memorysize_mb']))
        host['disks']['items'] = get_disks(host['name'],
                                           host['disks']['path_glob'])

    validate_cluster_desc(cluster_desc)

    nodes = cluster_nodes(cluster_desc)
    outs: List[Tuple[str, Callable[..., str], List[Any]]] = [
            ('bootstrap-env', generate_bootstrap_env, nodes),
            ('confd.dhall', generate_confd, [cluster_desc]),
    ]
    for path, generate, args in outs:
        with open(os.path.join(opts.output_dir, path), 'w') as f:
            f.write(generate(*args))


def all_unique(xs):
    """Returns True iff all entries of the sequence are unique.
    """
    if hasattr(xs, '__iter__') and hasattr(xs, '__next__'):
        # `xs` is a generator.  We should not consume it twice.
        xs = list(xs)
    return len(xs) == len(set(xs))


def validate_cluster_desc(desc: Dict[str, Any]):
    assert all_unique(host['name'] for host in desc['hosts'])

    hosts = [(h['name'], h['facts']['ipaddress']) for h in desc['hosts']]
    assert all_unique(ip for _name, ip in hosts), \
        'IP addresses are not unique:\n' + \
        '\n'.join('    ' + name + ' ' + ip for name, ip in hosts)

    total_nr_confds = 0

    for host in desc['hosts']:
        nr_confds = sum(1 for m0d in host['m0_servers'] if m0d['runs_confd'])
        assert nr_confds < 2, host['name'] + ': Too many confd services'
        total_nr_confds += nr_confds

        assert nr_confds + host['c0_clients'] + host['m0t1fs_clients'] > 0, \
            host['name'] + ': At least one Mero server or client is required'

    assert total_nr_confds > 0, 'At least one confd is required'


def run_command(hostname: str, *args: str) -> str:
    assert hostname

    cmd = []  # type: List[str]
    if hostname not in ('localhost', '127.0.0.1'):
        cmd = ['ssh', hostname]
    cmd.extend(args)
    return subprocess.check_output(cmd, timeout=15).decode()


Disk = NamedTuple('Disk', [('path', str), ('size', int)])
Disk.size.__doc__ = 'Total space in bytes'


# XXX see build_disk_info() in mero's `utils/m0genfacts`
def get_disks(hostname: str, path_glob: str) -> List[Disk]:
    cmd = ['sudo', 'python3', '-c', f"""\
import glob
import io

def blockdev_size(path):
    with open(path, 'rb') as f:
        return f.seek(0, io.SEEK_END)

print([dict(path=path, size=blockdev_size(path))
       for path in glob.glob({path_glob!r})])
"""]
    return [Disk(**kwargs) for kwargs in
            ast.literal_eval(run_command(hostname, *cmd))]


def get_facts(hostname: str, mock_p: bool, *args: str) -> Dict[str, Any]:
    if mock_p:
        return fabricate_facts(hostname, *args)

    cmd = ['facter', '--json']
    cmd.extend(args)
    return json.loads(run_command(hostname, *cmd))


def fabricate_facts(hostname: str, *args: str) -> Dict[str, Any]:
    rng = random.randrange
    fabricated = {
        'hostname': re.sub('[^@]*@', '', hostname),
        'processorcount': rng(1, 21),
        'memorysize_mb': '{:.2f}'.format(random.uniform(512, 16000)),
        'ipaddress': '.'.join(str(n) for n in [
            random.choice([10, 172, 192]), rng(256), rng(256), rng(256)]),
        'macaddress': ':'.join('{:02x}'.format(n) for n in [
            rng(256), rng(256), rng(256), rng(256), rng(256), rng(256)]),
    }
    return dict((k, fabricated[k]) for k in args)


def cluster_nodes(cluster_desc: Dict[str, Any]) -> Tuple[List[str], List[str]]:
    hosts = list((host['facts']['hostname'],
                  any(m0d['runs_confd'] for m0d in host['m0_servers']))
                 for host in cluster_desc['hosts'])
    servers = list(hostname for hostname, confd_p in hosts if confd_p)
    clients = list(hostname for hostname, confd_p in hosts if not confd_p)

    names = servers + clients
    assert all_unique(names)
    assert all(re.search('[",= @]', name) is None for name in names)

    return servers, clients


def generate_bootstrap_env(servers: List[str], clients: List[str]) -> str:
    return """\
consul_server_nodes={}
consul_client_nodes={}
""".format(','.join(servers), ','.join(clients))


ObjT = Enum('ObjT', 'root fdmi_flt_grp fdmi_filter'
            ' node process service sdev'  # software subtree
            ' site rack enclosure controller drive'  # hardware subtree
            ' pool pver pver_f objv'  # pool subtree
            ' profile')
ObjT.__doc__ = 'Mero conf object type'


def objT_to_dhall(t: ObjT) -> str:
    return 'ObjT.' + ''.join(s.capitalize() for s in t.name.split('_'))


Oid = NamedTuple('Oid', [('type', ObjT), ('fidk', int)])
Oid.__doc__ = 'Mero conf object identifier'
Oid.fidk.__doc__ = '.f_key part of the corresponding m0_fid'


def _infinite_counter():
    k = 0
    while True:
        yield k
        k += 1


_fidk = _infinite_counter()  # fid key generator


def new_oid(objt: ObjT) -> Oid:
    return Oid(objt, next(_fidk))


def oid_to_dhall(oid: Oid) -> str:
    return f'zoid {objT_to_dhall(oid.type)} {oid.fidk}'


def oids_to_dhall(oids: List[Oid]) -> str:
    if not oids:
        return '[] : List Oid'
    return '[ {} ]'.format(', '.join(oid_to_dhall(x) for x in oids))


class Endpoint:
    _tmids = {}  # type: Dict[str, int]

    def __init__(self, ipaddr: str, tmid: int = None):
        assert ipaddr
        self.ipaddr = ipaddr
        if tmid is None:
            self.tmid = Endpoint._tmids.setdefault(ipaddr, 1)
            Endpoint._tmids[ipaddr] += 1
        else:
            assert tmid > 0
            self.tmid = tmid

    def __repr__(self):
        args = ', '.join([f'ipaddr={self.ipaddr!r}', f'tmid={self.tmid}'])
        return f'{self.__class__.__name__}({args})'

    def to_dhall(self):
        return f'Endpoint/tcp "{self.ipaddr}" 1975 {self.tmid}'


class ToDhall(metaclass=abc.ABCMeta):
    @abc.abstractmethod
    def to_dhall(self, oid: Oid) -> str:
        pass


class ConfRoot(ToDhall):
    def __init__(self, nodes: List[Oid] = [], sites: List[Oid] = []):
        assert all(x.type is ObjT.node for x in nodes)
        self.nodes = nodes
        assert all(x.type is ObjT.site for x in sites)
        self.sites = sites

    def __repr__(self):
        return f'{self.__class__.__name__}(nodes={self.nodes},' \
            f' sites={self.sites})'

    def to_dhall(self, oid: Oid) -> str:
        assert oid.type is ObjT.root
        args = ', '.join([f'id = {oid_to_dhall(oid)}',
                          'mdpool = XXX',
                          'imeta_pver = XXX',
                          f'nodes = {oids_to_dhall(self.nodes)}',
                          f'sites = {oids_to_dhall(self.sites)}',
                          'pools = [XXX]',
                          'profiles = [XXX]'])
        return '{ %s }' % args


class ConfNode(ToDhall):
    def __init__(self, nr_cpu: int, memsize_MB: int,
                 processes: List[Oid] = []):
        self.nr_cpu = nr_cpu
        self.memsize_MB = memsize_MB
        assert all(x.type is ObjT.process for x in processes)
        self.processes = processes

    def __repr__(self):
        args = ', '.join([f'nr_cpu={self.nr_cpu}',
                          f'memsize_MB={self.memsize_MB}',
                          f'processes={self.processes}'])
        return f'{self.__class__.__name__}({args})'

    def to_dhall(self, oid: Oid) -> str:
        assert oid.type is ObjT.node
        args = ', '.join([f'id = {oid_to_dhall(oid)}',
                          f'nr_cpu = {self.nr_cpu}',
                          f'memsize_MB = {self.memsize_MB}',
                          f'processes = {oids_to_dhall(self.processes)}'])
        return '{ %s }' % args

    @classmethod
    def build(cls, m0conf: Dict[Oid, Any], parent: Oid,
              host_facts: Dict[str, Any]) -> Oid:
        assert parent.type is ObjT.root
        node_id = new_oid(ObjT.node)
        m0conf[node_id] = cls(nr_cpu=host_facts['processorcount'],
                              memsize_MB=host_facts['_memsize_MB'])
        m0conf[parent].nodes.append(node_id)
        return node_id


class ConfProcess(ToDhall):
    def __init__(self, nr_cpu: int, memsize_MB: int, endpoint: Endpoint,
                 services: List[Oid] = []):
        assert nr_cpu > 0
        self.nr_cpu = nr_cpu
        assert memsize_MB > 0
        self.memsize_MB = memsize_MB
        self.endpoint = endpoint
        assert all(x.type is ObjT.service for x in services)
        self.services = services

    def __repr__(self):
        args = ', '.join([f'nr_cpu={self.nr_cpu}',
                          f'memsize_MB={self.memsize_MB}',
                          f'endpoint={self.endpoint}',
                          f'services={self.services}'])
        return f'{self.__class__.__name__}({args})'

    def to_dhall(self, oid: Oid) -> str:
        assert oid.type is ObjT.process
        args = ', '.join([f'id = {oid_to_dhall(oid)}',
                          f'nr_cpu = {self.nr_cpu}',
                          f'memsize_MB = {self.memsize_MB}',
                          f'endpoint = {self.endpoint.to_dhall()}',
                          f'services = {oids_to_dhall(self.services)}'])
        return '{ %s }' % args

    @classmethod
    def build(cls, m0conf: Dict[Oid, Any], parent: Oid,
              host_facts: Dict[str, Any],
              process_desc: Dict[str, Any] = None) -> Oid:
        assert parent.type is ObjT.node

        ep = Endpoint(ipaddr=host_facts['ipaddress'])
        proc_id = new_oid(ObjT.process)
        m0conf[proc_id] = cls(nr_cpu=host_facts['processorcount'],
                              memsize_MB=host_facts['_memsize_MB'],
                              endpoint=ep)
        m0conf[parent].processes.append(proc_id)

        for stype in service_types(process_desc):
            ConfService.build(m0conf, proc_id, stype, ep)
        return proc_id


# m0_conf_service_type
class SvcT(Enum):
    """Mero service type
    """
    M0_CST_MDS = auto()
    M0_CST_IOS = auto()
    M0_CST_CONFD = auto()
    M0_CST_RMS = auto()
    M0_CST_STATS = auto()
    M0_CST_HA = auto()
    M0_CST_SSS = auto()
    M0_CST_SNS_REP = auto()
    M0_CST_SNS_REB = auto()
    M0_CST_ADDB2 = auto()
    M0_CST_CAS = auto()
    M0_CST_DIX_REP = auto()
    M0_CST_DIX_REB = auto()
    M0_CST_DS1 = auto()
    M0_CST_DS2 = auto()
    M0_CST_FIS = auto()
    M0_CST_FDMI = auto()
    M0_CST_BE = auto()
    M0_CST_M0T1FS = auto()
    M0_CST_CLOVIS = auto()
    M0_CST_ISCS = auto()


class ConfService(ToDhall):
    def __init__(self, stype: SvcT, endpoint: Endpoint, sdevs: List[Oid] = []):
        self.type = stype
        self.endpoint = endpoint
        assert all(x.type is ObjT.sdev for x in sdevs)
        self.sdevs = sdevs

    def __repr__(self):
        args = ', '.join([f'stype={self.type}',
                          f'endpoint={self.endpoint}',
                          f'sdevs={self.sdevs}'])
        return f'{self.__class__.__name__}({args})'

    def to_dhall(self, oid: Oid) -> str:
        assert oid.type is ObjT.service
        args = ', '.join([f'id = {oid_to_dhall(oid)}',
                          f'type = SvcT.{self.type.name}',
                          f'endpoint = {self.endpoint.to_dhall()}',
                          f'sdevs = {oids_to_dhall(self.sdevs)}'])
        return '{ %s }' % args

    @classmethod
    def build(cls, m0conf: Dict[Oid, Any], parent: Oid,
              stype: SvcT, endpoint: Endpoint) -> Oid:
        assert parent.type is ObjT.process
        svc_id = new_oid(ObjT.service)
        m0conf[svc_id] = cls(stype, endpoint)
        m0conf[parent].services.append(svc_id)
        return svc_id


class ConfSite(ToDhall):
    def __init__(self, racks: List[Oid] = []):
        assert all(x.type is ObjT.rack for x in racks)
        self.racks = racks

    def __repr__(self):
        return f'{self.__class__.__name__}(racks={self.racks})'

    def to_dhall(self, oid: Oid) -> str:
        assert oid.type is ObjT.site
        args = ', '.join([f'id = {oid_to_dhall(oid)}',
                          f'racks = {oids_to_dhall(self.racks)}',
                          'pvers = [XXX]'])
        return '{ %s }' % args

    @classmethod
    def build(cls, m0conf: Dict[Oid, Any], parent: Oid) -> Oid:
        assert parent.type is ObjT.root
        site_id = new_oid(ObjT.site)
        m0conf[site_id] = cls()
        assert not m0conf[parent].sites
        m0conf[parent].sites = [site_id]  # NB: a single site
        return site_id


class ConfRack(ToDhall):
    def __init__(self, encls: List[Oid] = []):
        assert all(x.type is ObjT.enclosure for x in encls)
        self.encls = encls

    def __repr__(self):
        return f'{self.__class__.__name__}(encls={self.encls})'

    def to_dhall(self, oid: Oid) -> str:
        assert oid.type is ObjT.rack
        args = ', '.join([f'id = {oid_to_dhall(oid)}',
                          f'encls = {oids_to_dhall(self.encls)}',
                          'pvers = [XXX]'])
        return '{ %s }' % args

    @classmethod
    def build(cls, m0conf: Dict[Oid, Any], parent: Oid) -> Oid:
        assert parent.type is ObjT.site
        rack_id = new_oid(ObjT.rack)
        m0conf[rack_id] = cls()
        assert not m0conf[parent].racks
        m0conf[parent].racks = [rack_id]  # NB: a single rack
        return rack_id


class ConfEnclosure(ToDhall):
    def __init__(self, ctrls: List[Oid] = []):
        assert all(x.type is ObjT.controller for x in ctrls)
        self.ctrls = ctrls

    def __repr__(self):
        return f'{self.__class__.__name__}(ctrls={self.ctrls})'

    def to_dhall(self, oid: Oid) -> str:
        assert oid.type is ObjT.enclosure
        args = ', '.join([f'id = {oid_to_dhall(oid)}',
                          f'ctrls = {oids_to_dhall(self.ctrls)}',
                          'pvers = [XXX]'])
        return '{ %s }' % args

    @classmethod
    def build(cls, m0conf: Dict[Oid, Any], parent: Oid) -> Oid:
        assert parent.type is ObjT.rack
        encl_id = new_oid(ObjT.enclosure)
        m0conf[encl_id] = cls()
        m0conf[parent].encls.append(encl_id)
        return encl_id


class ConfController(ToDhall):
    def __init__(self, node: Oid, drives: List[Oid] = []):
        assert node.type is ObjT.node
        self.node = node
        assert all(x.type is ObjT.drive for x in drives)
        self.drives = drives

    def __repr__(self):
        return f'{self.__class__.__name__}(node={self.node},' \
            f' drives={self.drives})'

    def to_dhall(self, oid: Oid) -> str:
        assert oid.type is ObjT.controller
        args = ', '.join([f'id = {oid_to_dhall(oid)}',
                          f'node = {oid_to_dhall(self.node)}',
                          f'drives = {oids_to_dhall(self.drives)}',
                          'pvers = [XXX]'])
        return '{ %s }' % args

    @classmethod
    def build(cls, m0conf: Dict[Oid, Any], parent: Oid, node: Oid) -> Oid:
        assert parent.type is ObjT.enclosure
        assert node.type is ObjT.node

        ctrl_id = new_oid(ObjT.controller)
        m0conf[ctrl_id] = cls(node)
        assert not m0conf[parent].ctrls
        m0conf[parent].ctrls = [ctrl_id]  # enclosure:controller = 1:1
        return ctrl_id


def service_types(process_desc: Dict[str, Any] = None) -> List[SvcT]:
    # Every program that uses m0_halon_interface API (ha/halon/interface.h
    # in `mero` repository) must be represented by at least 3 conf objects
    # in the Mero conf cache: a process object and two service objects
    # (HA and RMS).
    #
    # See http://gitlab.mero.colo.seagate.com/mero/hare/issues/8
    ts = [SvcT.M0_CST_HA, SvcT.M0_CST_RMS]

    if process_desc is not None:
        if process_desc.get('runs_confd'):
            ts.append(SvcT.M0_CST_CONFD)

        if process_desc['io_disks']['path_regex']:
            ts.extend([SvcT.M0_CST_IOS,
                       SvcT.M0_CST_SNS_REP,
                       SvcT.M0_CST_SNS_REB,
                       SvcT.M0_CST_ADDB2,
                       SvcT.M0_CST_CAS,
                       SvcT.M0_CST_ISCS])
    return ts


def build_m0conf(cluster_desc: Dict[str, Any]) -> Dict[Oid, ToDhall]:
    root_id = new_oid(ObjT.root)
    conf = {root_id: ConfRoot()}  # type: Dict[Oid, Any]

    rack_id = ConfRack.build(conf, ConfSite.build(conf, root_id))

    for host in cluster_desc['hosts']:
        facts = host['facts']

        node_id = ConfNode.build(conf, root_id, facts)
        ConfController.build(conf, ConfEnclosure.build(conf, rack_id), node_id)

        ConfProcess.build(conf, node_id, facts)  # `hax`

        for proc in host['m0_servers']:
            ConfProcess.build(conf, node_id, facts, proc)

        for _ in range(host['c0_clients'] + host['m0t1fs_clients']):
            ConfProcess.build(conf, node_id, facts)

    assert all(k.type.name == v.__class__.__name__[len('Conf'):].lower()
               for k, v in conf.items())
    return conf


def generate_confd(cluster_desc: Dict[str, Any]) -> str:
    m0conf = build_m0conf(cluster_desc)

    def objt(obj: ToDhall) -> str:
        objt = obj.__class__.__name__
        assert objt.startswith('Conf')
        return objt[len('Conf'):]

    return """\
let Endpoint/tcp = ./dhall/Endpoint/tcp
let Obj          = ./dhall/Conf/Obj/Obj
let ObjT         = ./dhall/Conf/ObjT/ObjT
let Oid          = ./dhall/Conf/Oid/Oid
let SvcT         = ./dhall/Conf/SvcT/SvcT
let confgen      = ./dhall/Conf/confgen
let zoid         = ./dhall/Conf/Oid/zoid

let objs =
  [ {}
  ]

in confgen objs
""".format('\n  , '.join('Obj.{} {}'.format(objt(v), v.to_dhall(k))
                         for k, v in m0conf.items()
                         # XXX DELETEME
                         if k.type not in (ObjT.root, ObjT.site, ObjT.rack,
                                           ObjT.enclosure, ObjT.controller)))


if __name__ == '__main__':
    main()
